<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="584" />
    <option name="newTranslationDialogX" value="2727" />
    <option name="newTranslationDialogY" value="450" />
    <histories>
      <item value="&lt;!-- Whether to split the track and leave a gap for the thumb drawable. --&gt;" />
      <item value="&lt;!-- Blending mode used to apply the background tint. --&gt; &lt;attr name=&quot;backgroundTintMode&quot;&gt; &lt;!-- The tint is drawn on top of the drawable. [Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa)Dc] --&gt; &lt;enum name=&quot;src_over&quot; value=&quot;3&quot; &gt; &lt;!-- The tint is masked by the alpha channel of the drawable. The drawable’s color channels are thrown out. [Sa Da, Sc Da] --&gt; &lt;enum name=&quot;src_in&quot; value=&quot;5&quot; &gt; &lt;!-- The tint is drawn above the drawable, but with the drawable’s alpha channel masking the result. [Da, Sc Da + (1 - Sa) Dc] --&gt; &lt;enum name=&quot;src_atop&quot; value=&quot;9&quot; &gt; &lt;!-- Multiplies the color and alpha channels of the drawable with those of the tint. [Sa Da, Sc Dc] --&gt; &lt;enum name=&quot;multiply&quot; value=&quot;14&quot; &gt; &lt;!-- [Sa + Da - Sa Da, Sc + Dc - Sc Dc] --&gt; &lt;enum name=&quot;screen&quot; value=&quot;15&quot; &gt; &lt;!-- Combines the tint and drawable color and alpha channels, clamping the result to valid color values. Saturate(S + D) --&gt; &lt;enum name=&quot;add&quot; value=&quot;16&quot; &gt; &lt;attr&gt;" />
      <item value="An offset for the thumb that allows it to extend out of the range of the track" />
      <item value="&lt;!-- State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view (or one of its parents) is currently selected. --&gt;" />
      <item value="&lt;!-- Constrains the text to a single horizontally scrolling line instead of letting it wrap onto multiple lines, and advances focus instead of inserting a newline when you press the enter key. The default value is false (multi-line wrapped text mode) for non-editable text, but if you specify any value for inputType, the default is true (single-line input field mode). {@deprecated This attribute is deprecated. Use &lt;code&gt;maxLines&lt;code&gt; instead to change the layout of a static text, and use the &lt;code&gt;textMultiLine&lt;code&gt; flag in the inputType attribute instead for editable text views (if both singleLine and inputType are supplied, the inputType flags will override the value of singleLine). } --&gt;" />
      <item value="When used on an editable text, the &lt;code&gt;inputType&lt;code&gt; attribute's value must be combined with the &lt;code&gt;textMultiLine&lt;code&gt; flag for the maxLines attribute to apply. --&gt;" />
      <item value="&lt;!-- Makes the TextView be exactly this many lines tall. --&gt;" />
      <item value="TODO(b76413401): make class final after the widget migration is finished" />
      <item value="Concurrent" />
      <item value="explode" />
      <item value="WARNING: An illegal reflective access operation has occurred" />
      <item value="Nothing, but ends quoting started by \Q" />
      <item value="Guaranteed to modify the current object by the isAutoCloneEnabledCheck" />
      <item value="payload" />
      <item value="Duplicate" />
      <item value="Remaining" />
      <item value="Protect the tunnel before connecting to avoid loopback." />
      <item value="TODO: The better way is to work with ConnectivityManager, trying only when the network is available. Here we just use a counter to keep things simple." />
      <item value="If anything needs to be obtained using the network, get it now. This greatly reduces the complexity of seamless handover, which tries to recreate the tunnel without shutting down everything. In this demo, all we need to know is the server address." />
      <item value="Authenticate and configure the virtual network interface." />
      <item value="PODCASTS" />
      <item value="Throttled" />
      <item value="Incorrect" />
      <item value="sensor Portrait" />
      <item value="Portrait" />
      <item value="sensor" />
      <item value="Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination]." />
      <item value="Poll" />
      <item value="e Poll" />
      <item value="using an in-memory database for testing, since it doesn't survive killing the process" />
      <item value="Simple factory, which calls empty constructor on the give class." />
      <item value="optimize" />
      <item value="Note, for testing and architecture purposes, it's bad practice to construct the repository here. We'll show you how to fix this during the codelab" />
      <item value="Note, for testing and architecture purposes, it's bad practice to construct the repository" />
      <item value="Note that Mockito's inline mock maker is not supported on Android." />
      <item value="Stub" />
      <item value="Matches any object, excluding nulls." />
      <item value="Matches any object of given type, excluding nulls." />
      <item value="check again right away, there may be another packet" />
      <item value="{ just read and ignore all data, regular read() is not interruptible" />
      <item value="If you're unsure why you're getting above error read on. Due to the nature of the syntax above problem might occur because: 1. This exception might occur in wrongly written multi-threaded tests. Please refer to Mockito FAQ on limitations of concurrency testing. 2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method." />
      <item value="We should ideally be splitting segments by MTUMSS, but this seems to work without" />
      <item value="Instrumented" />
      <item value="java.lang.IllegalStateException: No instrumentation registered! Must run under a registering instrumentation." />
      <item value="we specially request a new live data, otherwise we will get immediately last cached value, which may not be updated with latest results received from network." />
      <item value="Configure a builder while parsing the parameters" />
      <item value="To build a secured tunnel, we should perform mutual authentication and exchange session keys for encryption. To keep things simple in this demo, we just send the shared secret in plaintext and wait for the server to send the parameters. Allocate the buffer for handshaking. We have a hardcoded maximum handshake size of 1024 bytes, which should be enough for demo purposes." />
      <item value="Datagram Channel" />
      <item value="Datagram" />
      <item value="TODO: We don't expect out-of-order packets, but verify" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="206" />
        <entry key="ENGLISH" value="207" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1624255145605" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="phoneticFontFamily" value="Microsoft YaHei UI" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>