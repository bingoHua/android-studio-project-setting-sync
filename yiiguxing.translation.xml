<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="580" />
    <option name="newTranslationDialogX" value="686" />
    <option name="newTranslationDialogY" value="451" />
    <histories>
      <item value="new Single Thread Executor" />
      <item value="allow Core Thread Time Out" />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's {@code get} method will return {@code null} upon &lt;em&gt;successful&lt;em&gt; completion." />
      <item value="Proceed in 3 steps: 1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false. 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none. 3. If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task." />
      <item value="Check if queue empty only if necessary." />
      <item value="saturated" />
      <item value="Atomic" />
      <item value="&lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt; &lt;caption&gt;Comparison of Queue and Deque methods&lt;caption&gt; &lt;tr&gt; &lt;td ALIGN=CENTER&gt; &lt;b&gt;{@code Queue} Method&lt;b&gt;&lt;td&gt; &lt;td ALIGN=CENTER&gt; &lt;b&gt;Equivalent {@code Deque} Method&lt;b&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queueadd add(e)}&lt;td&gt; &lt;td&gt;{@link addLast addLast(e)}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queueoffer offer(e)}&lt;td&gt; &lt;td&gt;{@link offerLast offerLast(e)}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queueremove remove()}&lt;td&gt; &lt;td&gt;{@link removeFirst removeFirst()}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queuepoll poll()}&lt;td&gt; &lt;td&gt;{@link pollFirst pollFirst()}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queueelement element()}&lt;td&gt; &lt;td&gt;{@link getFirst getFirst()}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link java.util.Queuepeek peek()}&lt;td&gt; &lt;td&gt;{@link peek peekFirst()}&lt;td&gt; &lt;tr&gt; &lt;table&gt; &lt;p&gt;Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy {@link Stack} class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to {@code Deque} methods as indicated in the table below: &lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt; &lt;caption&gt;Comparison of Stack and Deque methods&lt;caption&gt; &lt;tr&gt; &lt;td ALIGN=CENTER&gt; &lt;b&gt;Stack Method&lt;b&gt;&lt;td&gt; &lt;td ALIGN=CENTER&gt; &lt;b&gt;Equivalent {@code Deque} Method&lt;b&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link push push(e)}&lt;td&gt; &lt;td&gt;{@link addFirst addFirst(e)}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link pop pop()}&lt;td&gt; &lt;td&gt;{@link removeFirst removeFirst()}&lt;td&gt; &lt;tr&gt; &lt;tr&gt; &lt;td&gt;{@link peek peek()}&lt;td&gt; &lt;td&gt;{@link peekFirst peekFirst()}&lt;td&gt; &lt;tr&gt; &lt;table&gt; &lt;p&gt;Note that the {@link peek peek} method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque. &lt;p&gt;This interface provides two methods to remove interior elements, {@link removeFirstOccurrence removeFirstOccurrence} and {@link removeLastOccurrence removeLastOccurrence}. &lt;p&gt;Unlike the {@link List} interface, this interface does not provide support for indexed access to elements. &lt;p&gt;While {@code Deque} implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any {@code Deque} implementations that do allow null elements are strongly encouraged &lt;i&gt;not&lt;i&gt; to take advantage of the ability to insert nulls. This is so because {@code null} is used as a special return value by various methods to indicated that the deque is empty. &lt;p&gt;{@code Deque} implementations generally do not define element-based versions of the {@code equals} and {@code hashCode} methods, but instead inherit the identity-based versions from class {@code Object}." />
      <item value="Clears internal storage and notifies ViewModels that they are no longer used." />
      <item value="同步" />
      <item value="asynchronous" />
      <item value="Whether to use unbounded ripple effect for tabs, or if ripple should instead be bound to tab item bounds. --&gt; &lt;" />
      <item value="SETTLING" />
      <item value="The bottom sheet is settling" />
      <item value="Make sure all children have been properly measured. Decor views first. Right now we cheat and make this less complicated by assuming decor views won't intersect. We will pin to edges based on gravity." />
      <item value="Excess" />
      <item value="For simple implementation, our internal size is always 0. We depend on the container to specify the layout size of our view. We can't really know what it is since we will be adding and removing different arbitrary views and do not want the layout to change as this happens." />
      <item value="Try first for an exact, non-invalid match from scrap." />
      <item value="0) If there is a changed scrap, try to find from there" />
      <item value="VERTICAL" />
      <item value="HORIZONTAL" />
      <item value="1) by checking children and other variables, find an anchor coordinate and an anchor item position. 2) fill towards start, stacking from bottom 3) fill towards end, stacking from top 4) scroll to fulfill requirements like stack from bottom. create layout state" />
      <item value="Check that graphics HAL is generating vsync timestamps using the correct timebase" />
      <item value="Horizontally" />
      <item value="Nested" />
      <item value="Indicates that the input type for the gesture is from a user touching the screen." />
      <item value="Indicates" />
      <item value="Vertically" />
      <item value="Translucent" />
      <item value="Exposure" />
      <item value="Aperture" />
      <item value=".Exposure" />
      <item value="SHUTTER" />
      <item value="APERTURE" />
      <item value="Called when the parent CoordinatorLayout is about the lay out the given child view. &lt;p&gt;This method can be used to perform custom or modified layout of a child view in place of the default child layout behavior. The Behavior's implementation can delegate to the standard CoordinatorLayout measurement behavior by calling {@link CoordinatorLayoutonLayoutChild(View, int) parent.onLayoutChild}.&lt;p&gt; &lt;p&gt;If a Behavior implements {@link onDependentViewChanged(CoordinatorLayout, View, View)} to change the position of a view in response to a dependent view changing, it should also implement &lt;code&gt;onLayoutChild&lt;code&gt; in such a way that respects those dependent views. &lt;code&gt;onLayoutChild&lt;code&gt; will always be called for a dependent view &lt;em&gt;after&lt;em&gt; its dependency has been laid out.&lt;p&gt; @param parent the parent CoordinatorLayout @param child child view to lay out @param layoutDirection the resolved layout direction for the CoordinatorLayout, such as {@link ViewCompatLAYOUT_DIRECTION_LTR} or {@link ViewCompatLAYOUT_DIRECTION_RTL}. @return true if the Behavior performed layout of the child view, false to request default layout behavior" />
      <item value="A fake drag is in progress already, ignore this real one but still eat the touch events. (It is likely that the user is multi-touching the screen.)" />
      <item value="Out-projected type'BaseItem&lt;*&gt;' prohibits the use of'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Out-projected type 'BaseItem&lt;*&gt;' 禁止使用 'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Out-projected type 'BaseItem&lt;*&gt;' prohibits the use of 'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Myers' algorithm uses two lists as axis labels. In DiffUtil's implementation, `x` axis is used for old list and `y` axis is used for new list." />
      <item value="Assuming the thumb drawable is symmetric, set the thumb offset such that the thumb will hang halfway off either edge of the progress bar." />
      <item value="&lt;!-- Whether to split the track and leave a gap for the thumb drawable. --&gt;" />
      <item value="&lt;!-- Blending mode used to apply the background tint. --&gt; &lt;attr name=&quot;backgroundTintMode&quot;&gt; &lt;!-- The tint is drawn on top of the drawable. [Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa)Dc] --&gt; &lt;enum name=&quot;src_over&quot; value=&quot;3&quot; &gt; &lt;!-- The tint is masked by the alpha channel of the drawable. The drawable’s color channels are thrown out. [Sa Da, Sc Da] --&gt; &lt;enum name=&quot;src_in&quot; value=&quot;5&quot; &gt; &lt;!-- The tint is drawn above the drawable, but with the drawable’s alpha channel masking the result. [Da, Sc Da + (1 - Sa) Dc] --&gt; &lt;enum name=&quot;src_atop&quot; value=&quot;9&quot; &gt; &lt;!-- Multiplies the color and alpha channels of the drawable with those of the tint. [Sa Da, Sc Dc] --&gt; &lt;enum name=&quot;multiply&quot; value=&quot;14&quot; &gt; &lt;!-- [Sa + Da - Sa Da, Sc + Dc - Sc Dc] --&gt; &lt;enum name=&quot;screen&quot; value=&quot;15&quot; &gt; &lt;!-- Combines the tint and drawable color and alpha channels, clamping the result to valid color values. Saturate(S + D) --&gt; &lt;enum name=&quot;add&quot; value=&quot;16&quot; &gt; &lt;attr&gt;" />
      <item value="An offset for the thumb that allows it to extend out of the range of the track" />
      <item value="&lt;!-- State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view (or one of its parents) is currently selected. --&gt;" />
      <item value="&lt;!-- Constrains the text to a single horizontally scrolling line instead of letting it wrap onto multiple lines, and advances focus instead of inserting a newline when you press the enter key. The default value is false (multi-line wrapped text mode) for non-editable text, but if you specify any value for inputType, the default is true (single-line input field mode). {@deprecated This attribute is deprecated. Use &lt;code&gt;maxLines&lt;code&gt; instead to change the layout of a static text, and use the &lt;code&gt;textMultiLine&lt;code&gt; flag in the inputType attribute instead for editable text views (if both singleLine and inputType are supplied, the inputType flags will override the value of singleLine). } --&gt;" />
      <item value="When used on an editable text, the &lt;code&gt;inputType&lt;code&gt; attribute's value must be combined with the &lt;code&gt;textMultiLine&lt;code&gt; flag for the maxLines attribute to apply. --&gt;" />
      <item value="&lt;!-- Makes the TextView be exactly this many lines tall. --&gt;" />
      <item value="TODO(b76413401): make class final after the widget migration is finished" />
      <item value="Concurrent" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="206" />
        <entry key="ENGLISH" value="207" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1628387939393" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="phoneticFontFamily" value="Microsoft YaHei UI" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>