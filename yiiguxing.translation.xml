<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="582" />
    <option name="newTranslationDialogX" value="686" />
    <option name="newTranslationDialogY" value="451" />
    <histories>
      <item value="Slide" />
      <item value="Execute enqueued actions on every traversal in case a detached view enqueued an action" />
      <item value="Hierarchy" />
      <item value="requestLayout() was called during layout. If no layout-request flags are set on the requesting views, there is no problem. If some requests are still pending, then we need to clear those flags and do a full requestmeasurelayout pass to handle this situation." />
      <item value="Process fresh layout requests, then measure and layout" />
      <item value="Clear this now, so that if anything requests a layout in the rest of this function we will catch it and re-run a full layout pass." />
      <item value="Choreographer" />
      <item value="do this last because it fires off messages to start doing things" />
      <item value="Don't set application object here -- if the system crashes, we can't display an alert, we just want to die die die." />
      <item value="The system process on low-memory devices do not get to use hardware accelerated drawing, since this can add too much overhead to the process." />
      <item value="SETTLING" />
      <item value="The bottom sheet is settling" />
      <item value="Make sure all children have been properly measured. Decor views first. Right now we cheat and make this less complicated by assuming decor views won't intersect. We will pin to edges based on gravity." />
      <item value="Excess" />
      <item value="For simple implementation, our internal size is always 0. We depend on the container to specify the layout size of our view. We can't really know what it is since we will be adding and removing different arbitrary views and do not want the layout to change as this happens." />
      <item value="Try first for an exact, non-invalid match from scrap." />
      <item value="0) If there is a changed scrap, try to find from there" />
      <item value="VERTICAL" />
      <item value="HORIZONTAL" />
      <item value="1) by checking children and other variables, find an anchor coordinate and an anchor item position. 2) fill towards start, stacking from bottom 3) fill towards end, stacking from top 4) scroll to fulfill requirements like stack from bottom. create layout state" />
      <item value="Check that graphics HAL is generating vsync timestamps using the correct timebase" />
      <item value="Horizontally" />
      <item value="Nested" />
      <item value="Indicates that the input type for the gesture is from a user touching the screen." />
      <item value="Indicates" />
      <item value="Vertically" />
      <item value="Translucent" />
      <item value="Exposure" />
      <item value="Aperture" />
      <item value=".Exposure" />
      <item value="SHUTTER" />
      <item value="APERTURE" />
      <item value="Called when the parent CoordinatorLayout is about the lay out the given child view. &lt;p&gt;This method can be used to perform custom or modified layout of a child view in place of the default child layout behavior. The Behavior's implementation can delegate to the standard CoordinatorLayout measurement behavior by calling {@link CoordinatorLayoutonLayoutChild(View, int) parent.onLayoutChild}.&lt;p&gt; &lt;p&gt;If a Behavior implements {@link onDependentViewChanged(CoordinatorLayout, View, View)} to change the position of a view in response to a dependent view changing, it should also implement &lt;code&gt;onLayoutChild&lt;code&gt; in such a way that respects those dependent views. &lt;code&gt;onLayoutChild&lt;code&gt; will always be called for a dependent view &lt;em&gt;after&lt;em&gt; its dependency has been laid out.&lt;p&gt; @param parent the parent CoordinatorLayout @param child child view to lay out @param layoutDirection the resolved layout direction for the CoordinatorLayout, such as {@link ViewCompatLAYOUT_DIRECTION_LTR} or {@link ViewCompatLAYOUT_DIRECTION_RTL}. @return true if the Behavior performed layout of the child view, false to request default layout behavior" />
      <item value="A fake drag is in progress already, ignore this real one but still eat the touch events. (It is likely that the user is multi-touching the screen.)" />
      <item value="Out-projected type'BaseItem&lt;*&gt;' prohibits the use of'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Out-projected type 'BaseItem&lt;*&gt;' 禁止使用 'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Out-projected type 'BaseItem&lt;*&gt;' prohibits the use of 'public abstract fun areContentSame(baseItem: BaseItem&lt;T&gt;): Boolean defined in com.arashivision.insta360.share.ui.akiko.configBottomSheet.itemWidgets.BaseItem'" />
      <item value="Myers' algorithm uses two lists as axis labels. In DiffUtil's implementation, `x` axis is used for old list and `y` axis is used for new list." />
      <item value="Assuming the thumb drawable is symmetric, set the thumb offset such that the thumb will hang halfway off either edge of the progress bar." />
      <item value="&lt;!-- Whether to split the track and leave a gap for the thumb drawable. --&gt;" />
      <item value="&lt;!-- Blending mode used to apply the background tint. --&gt; &lt;attr name=&quot;backgroundTintMode&quot;&gt; &lt;!-- The tint is drawn on top of the drawable. [Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa)Dc] --&gt; &lt;enum name=&quot;src_over&quot; value=&quot;3&quot; &gt; &lt;!-- The tint is masked by the alpha channel of the drawable. The drawable’s color channels are thrown out. [Sa Da, Sc Da] --&gt; &lt;enum name=&quot;src_in&quot; value=&quot;5&quot; &gt; &lt;!-- The tint is drawn above the drawable, but with the drawable’s alpha channel masking the result. [Da, Sc Da + (1 - Sa) Dc] --&gt; &lt;enum name=&quot;src_atop&quot; value=&quot;9&quot; &gt; &lt;!-- Multiplies the color and alpha channels of the drawable with those of the tint. [Sa Da, Sc Dc] --&gt; &lt;enum name=&quot;multiply&quot; value=&quot;14&quot; &gt; &lt;!-- [Sa + Da - Sa Da, Sc + Dc - Sc Dc] --&gt; &lt;enum name=&quot;screen&quot; value=&quot;15&quot; &gt; &lt;!-- Combines the tint and drawable color and alpha channels, clamping the result to valid color values. Saturate(S + D) --&gt; &lt;enum name=&quot;add&quot; value=&quot;16&quot; &gt; &lt;attr&gt;" />
      <item value="An offset for the thumb that allows it to extend out of the range of the track" />
      <item value="&lt;!-- State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view (or one of its parents) is currently selected. --&gt;" />
      <item value="&lt;!-- Constrains the text to a single horizontally scrolling line instead of letting it wrap onto multiple lines, and advances focus instead of inserting a newline when you press the enter key. The default value is false (multi-line wrapped text mode) for non-editable text, but if you specify any value for inputType, the default is true (single-line input field mode). {@deprecated This attribute is deprecated. Use &lt;code&gt;maxLines&lt;code&gt; instead to change the layout of a static text, and use the &lt;code&gt;textMultiLine&lt;code&gt; flag in the inputType attribute instead for editable text views (if both singleLine and inputType are supplied, the inputType flags will override the value of singleLine). } --&gt;" />
      <item value="When used on an editable text, the &lt;code&gt;inputType&lt;code&gt; attribute's value must be combined with the &lt;code&gt;textMultiLine&lt;code&gt; flag for the maxLines attribute to apply. --&gt;" />
      <item value="&lt;!-- Makes the TextView be exactly this many lines tall. --&gt;" />
      <item value="TODO(b76413401): make class final after the widget migration is finished" />
      <item value="Concurrent" />
      <item value="explode" />
      <item value="WARNING: An illegal reflective access operation has occurred" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="206" />
        <entry key="ENGLISH" value="207" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1626502189460" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="phoneticFontFamily" value="Microsoft YaHei UI" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>