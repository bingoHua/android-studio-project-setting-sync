<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="584" />
    <option name="newTranslationDialogX" value="2727" />
    <option name="newTranslationDialogY" value="450" />
    <histories>
      <item value="Portrait" />
      <item value="sensor" />
      <item value="Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination]." />
      <item value="Poll" />
      <item value="e Poll" />
      <item value="using an in-memory database for testing, since it doesn't survive killing the process" />
      <item value="Simple factory, which calls empty constructor on the give class." />
      <item value="optimize" />
      <item value="Note, for testing and architecture purposes, it's bad practice to construct the repository here. We'll show you how to fix this during the codelab" />
      <item value="Note, for testing and architecture purposes, it's bad practice to construct the repository" />
      <item value="Note that Mockito's inline mock maker is not supported on Android." />
      <item value="Stub" />
      <item value="Matches any object, excluding nulls." />
      <item value="Matches any object of given type, excluding nulls." />
      <item value="check again right away, there may be another packet" />
      <item value="{ just read and ignore all data, regular read() is not interruptible" />
      <item value="If you're unsure why you're getting above error read on. Due to the nature of the syntax above problem might occur because: 1. This exception might occur in wrongly written multi-threaded tests. Please refer to Mockito FAQ on limitations of concurrency testing. 2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method." />
      <item value="We should ideally be splitting segments by MTUMSS, but this seems to work without" />
      <item value="Instrumented" />
      <item value="java.lang.IllegalStateException: No instrumentation registered! Must run under a registering instrumentation." />
      <item value="we specially request a new live data, otherwise we will get immediately last cached value, which may not be updated with latest results received from network." />
      <item value="Configure a builder while parsing the parameters" />
      <item value="Authenticate and configure the virtual network interface." />
      <item value="To build a secured tunnel, we should perform mutual authentication and exchange session keys for encryption. To keep things simple in this demo, we just send the shared secret in plaintext and wait for the server to send the parameters. Allocate the buffer for handshaking. We have a hardcoded maximum handshake size of 1024 bytes, which should be enough for demo purposes." />
      <item value="Datagram Channel" />
      <item value="Datagram" />
      <item value="TODO: We don't expect out-of-order packets, but verify" />
      <item value="TODO: Set MSS for receiving larger packets from the device" />
      <item value="mutability" />
      <item value="Duplicate" />
      <item value="Reduce public mutability" />
      <item value="addViewInner() will call child.requestLayout() when setting the new LayoutParams therefore, we call requestLayout() on ourselves before, so that the child's request will be blocked at our level" />
      <item value="Coroutines Api" />
      <item value="Android-changed. Removed javadoc comment about special privileges that doesn't make sense on android" />
      <item value="PRIMARY" />
      <item value="Since we draw translated, the drawable's bounds that it signals for invalidation won't be the actual bounds we want invalidated, so just invalidate this whole view." />
      <item value="Indeterminate" />
      <item value="indeterminate" />
      <item value="consider" />
      <item value="Using individually bound Sockets created by Network.getSocketFactory().createSocket() and performing network-specific host name resolutions via {@link NetworkgetAllByName Network.getAllByName} is preferred to calling {@code bindProcessToNetwork}." />
      <item value="performing network-specific host name resolutions via {@link NetworkgetAllByName Network.getAllByName} is preferred to calling {@code bindProcessToNetwork}." />
      <item value="is preferred to" />
      <item value="Note that if {@code network} ever disconnects, all Sockets created in this way will cease to work and all host name resolutions will fail." />
      <item value="This is by design" />
      <item value="accidentally" />
      <item value="This is by design so an application doesn't accidentally use Sockets it thinks are still bound to a particular {@link Network}." />
      <item value="particular" />
      <item value="host name resolutions" />
      <item value="resolutions" />
      <item value="cease" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="206" />
        <entry key="ENGLISH" value="207" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1622557507054" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="phoneticFontFamily" value="Microsoft YaHei UI" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>